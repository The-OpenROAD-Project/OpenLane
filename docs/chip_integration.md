**DISCLAIMER: THIS PAGE IS STILL UNDER DEVELOPMENT.**
**THE INFORMATION HERE MIGHT BE INCORRECT OR OUTDATED.**

# Chip Integration

Using openlane, you can produce a GDSII from a chip RTL.


## The current Methodology

The current methodology views the chip using the following hierarchy:
- Chip Core
    - The hard macros
    - The rest of the design
- Chip IO
    - IO Pads
    - Power Pads
    - Corener Pads

The current methodology goes as follows:
1. Hardening the hard macros.
2. Hardening the core with the hard macros inside it.
3. Hardening the full chip with the padframe.


## Hardening The Macros

This is discussed in more detail [here][8].

## Hardening The Core

The chip core would usually have other macros inside it.

You need to set the following environment variables in your `config.tcl` file for the chip core:
- `::env(VERILOG_FILES)` To point at the used verilog files; those that were not previously hardened.
- `::env(VERILOG_FILES_BLACKBOX)` To point at the blackboxes (the hardened macros).
- `::env(EXTRA_LEFS)` To point at the LEF files of the hardened macros.
- `::env(EXTRA_GDS_FILES)` To point at the GDS files of the hardened macros.

Therefore, the verilog files shouldn't have any includes in any of your verilog files. But use `::env(VERILOG_FILES)` and `::env(VERILOG_FILES_BLACKBOX)` for that purpose.

Add `set ::env(SYNTH_READ_BLACKBOX_LIB) 1`, if you have `::env(VERILOG_FILES_BLACKBOX)` in your configuration file.

You can follow the same instructions provided [here][8] for the rest of the hardenning steps.

In case you want to manually place the macros in specific locations, [this][9] should provide a good example on how to do it.

[Here][0] you can find a list of all the available OpenLANE configuartions.

Check this [section](#power-routing) for more details on power routing setup.

## Hardening The Full Chip


The full chip requires an [interactive script][2] to harden. You could take this [full chip][5] as an example.

You need to set the following environment variables in your `config.tcl` file for the chip:
- `::env(VERILOG_FILES)` To point at the used verilog files; those that were not previously hardened. Ideally, this should be only one file.
- `::env(VERILOG_FILES_BLACKBOX)` To point at the blackboxes (the hardened macros). Ideally, this should include all the other verilog files.
- `::env(EXTRA_LEFS)` To point at the LEF files of the hardened core macro.
- `::env(EXTRA_GDS_FILES)` To point at the GDS files of the hardened core macro.

Therefore, the verilog files shouldn't have any includes in any of your verilog files. But use `::env(VERILOG_FILES)` and `::env(VERILOG_FILES_BLACKBOX)` for that purpose.

Add `set ::env(SYNTH_READ_BLACKBOX_LIB) 1`, if you have `::env(VERILOG_FILES_BLACKBOX)` in your configuration file.

Add `set ::env(SYNTH_FLAT_TOP) 1` to your `config.tcl`. To flatten the padframe, if it's presented in a `chip_io` module.

The following inputs are provided to produce the final GDSII:

1. Padframe cfg file (provided by the user or generated by padring). [Here][6] is an example.
2. Hardened lef & GDS-II for the core module, generated [here](#hardening-the-core)
3. Top level netlist instantiating pads and core module (Could be provided by the user or generated by [topModuleGen][7])

**Note:** The chip Verilog file should contain a guard `ifdef PFG` under which all the verilog file names should be included, without specifying a directory. This includes the verilog for the pads as well.

Given these inputs the following [interactive script][5] script. Mainly, it does the following steps:
-  set `padframe_root $::env(TMP_DIR)/padframe/<chip design name>/`.
-  Copy all the lef files (of all the macros and power/corner/io pads) to `$padframe/mag`, and all the verilog files to `$padframe/verilog`.
-  Copy the padframe cfg file to `$padframe/mag`.
-  Combine the pads lef, macros lefs and tech lef in one lef file.
-  Use padring to generate the padframe.def and the core.def.
-  Parse the padframe cfg file to get the diearea and input it to the floorplanner.
-  Run the top level netlist through yosys.
-  Running `chip_floorplan` which first generates a floorplan using `verilog2def` followed by removing PINS section and cleaning NETS section in the generated def file.
-  Replace the components of the floorplan def file with placed components from padframe def file and core def file.
-  Perform manual placement if desired.
-  legalize the placement.
-  Perform `power_routing`.
-  Route the design.
-  Perform power routing.
-  Generate a GDSII file of the routed design.
-  Run DRC and LVS checks.

## Power_routing

### Macros:

This is discussed in detail [here][8].

### Core:

It should have an `stdcell` section that includes a `core_ring` on met4 and met5. It should use met5 and met4 for the straps, and met1 for the rails. Thus, make sure to add these to your config file:

```tcl
set ::env(DESIGN_IS_CORE) 1
set ::env(FP_PDN_CORE_RING) 1
```

If your core contains other macros inside it. Then make sure to check the `macro` section and see if it requires any modifications for each of them depending on their special configs. The default section specifies that metal4 pins should be hooked up to the metal5 straps.

Refer to [this][3] for more details about the syntax. In case you needed to create your own `pdn.tcl` then point to it using `PDN_CFG`.

When you use the `power_routing` command in the chip interactive script, the power pads will be connected to the core ring, and thus the whole chip would be powered.

## General Notes:

[This][2] includes more guidance on how to create an interactive script.

[This][0] documents all OpenLANE configurations.

[This][1] has a description for all OpenLANE commands.

[0]: ./../configuration/README.md
[1]: ./OpenLANE_commands.md
[2]: ./advanced_readme.md
[3]: https://github.com/The-OpenROAD-Project/OpenROAD/blob/openroad/src/pdngen/doc/PDN.md
[4]: Reference_for_interactive_script_core
[5]: Reference_for_interactive_script_chip
[6]: Example_padframe_cfg_file
[7]: ./../scripts/topModuleGen/README.md
[8]: ./hardening_macros
[9]: ./../designs/manual_macro_placement_test/
