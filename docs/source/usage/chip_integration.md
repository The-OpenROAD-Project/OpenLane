# Chip Level Integration
Using OpenLane, you can produce a GDSII from a chip RTL.

## The Current Methodology

The current methodology views the chip using the following hierarchy:
- Chip Core
    - The hard macros
    - The rest of the design
- Chip IO
    - IO Pads
    - Power Pads
    - Corner Pads

The current methodology goes as follows:
1. Hardening the hard macros.
2. Hardening the core with the hard macros inside it.
3. Hardening the padframe
4. Hardening the full chip with the padframe.


## Hardening Macros

This is discussed in more detail [here][8].

## Hardening The Core

The chip core would usually have other macros inside it.

You need to set the following environment variables in your configuration file for the chip core:

| Key | Description |
|-|-|
| `VERILOG_FILES` | Whitespace-delimited list of Verilog files*. |
| `VERILOG_FILES_BLACKBOX` | Black-box, Verilog files where the implementation is ignored. Useful for pre-hardened macros you incorporate into your design. |
| `EXTRA_LEFS` | LEF files for pre-hardened macros you incorporate into your design. |
| `EXTRA_LIBS` | Specifies LIB files of pre-hardened macros used in the current design, used to improve timing analysis. (Optional) |
| `EXTRA_GDS_FILES` | GDS files for pre-hardened macros you incorporate into your design. |
| `SYNTH_READ_BLACKBOX_LIB` | `1/0` (Tcl), `true/false` (JSON): Should be set to true if you are using any standard cells directly in your design, i.e., your design does not function purely at the register transfer level. |
| `MACRO_PLACEMENT_CFG` | A path to a file containing a line-break delimited list of instances and positions if you want to manually place the macros in specific locations, in the format `instance_name X_pos Y_pos Orientation`. The [`manual_macro_placement_test` example][9] under designs should be a good example. |
> \* The ``` `include ``` directive is not supported.

You can follow the same instructions provided [here][8] for the rest of the hardenning steps.

[Here][0] you can find a list of all the available OpenLane configuration variables.

## Hardening The Full Chip

The full chip requires an [interactive script][2] to harden. You could take this [full chip][5] as an example.

First you need to harden the padframe as a separate macro, check [this flow][4] as an example on how to do so.

You need to set ***all environment variables mentioned in [Hardening the Core](#hardening-the-core)***, but also:

| Key | Description |
|-|-|
| `SYNTH_FLAT_TOP` | `1/0` (Tcl), `true/false` (JSON): Flattens the padframe if true (and presented in a chip_io module). Otherwise, you can harden it separately as indicated in [this flow][4].  |

The following inputs are provided to produce the final GDSII:

1. Padframe cfg file (provided by the user or generated by padring). [Here][6] is an example. Or a hardened chip_io.gds and chip_io.lef following [this][4].
2. Hardened lef & GDSII for the core module, generated [here](#hardening-the-core)
3. Top level netlist instantiating pads and core module (Could be provided by the user or generated by topModuleGen)

[The interactive script for the IOs][4] does the following:
- Sources configurations.
- Elaborates the verilog.
- Runs floorplan.
- Uses odbpy/padringer.py to generate the padframe.
- Adds the obstructions to the core area, and removes core nets and pins.
- Routes.
- Streams out the GDSII and the LEFv view.

Given these inputs the following [interactive script][5] script. Mainly, it does the following steps:
-  Runs the top level netlist through yosys.
-  Runs floorplan.
-  Performs manual placement of the core macros, this sample has many cores, however for full automation you should have only a single core.
-  Legalize the placement.
-  Removes Nets and Pins to a different file.
-  This stages is skipped because the design has many cores and so fully automated power routing is not possible. However if you only have a single core, you can perform automatic power routing by adding `power_routing` at this stage in your interactive script.
-  Route the design.
-  Perform power routing.
-  Generate a GDSII file of the routed design.
-  Run DRC and LVS checks [here][11].

## Power_routing

### Macros

This is discussed in detail [here][8].

### Core

It should have an `stdcell` section that includes a `core_ring` on met4 and met5. It should use met5 and met4 for the straps, and met1 for the rails. Thus, make sure to add these to your config file:

<table>
<tr><th>JSON</th><th>Tcl</th></tr>
<tr>
<td>
    
```json
    "DESIGN_IS_CORE": true,
    "FP_PDN_CORE_RING": true
```


</td>
<td>

```tcl
    set ::env(DESIGN_IS_CORE) 1
    set ::env(FP_PDN_CORE_RING) 1
```
</td>
</tr>
</table>

You can automate the power routing process in the core and macro level by reading [this documentation][10]. Otherwise, refer to [this][3] for more details about the syntax. In case you needed to create your own `pdn.tcl` then point to it using `FP_PDN_CFG`.

When you use the `power_routing` command in the chip interactive script, the power pads will be connected to the core ring, and thus the whole chip would be powered.

## General Notes

[This][2] includes more guidance on how to create an interactive script.

[This][0] documents all OpenLane configurations.

[This][1] has a description for all OpenLane commands.

[0]: ../reference/configuration.md
[1]: ../reference/openlane_commands.md
[2]: ../reference/interactive_mode.md
[3]: https://openroad.readthedocs.io/en/latest/main/src/pdn/README.html
[4]: https://github.com/efabless/caravel/blob/9949306c42ded3cad03e1f4566d7cd1f8215b0bb/openlane/chip_io/interactive.tcl
[5]: https://github.com/efabless/caravel/blob/9949306c42ded3cad03e1f4566d7cd1f8215b0bb/openlane/caravel/interactive.tcl
[6]: https://github.com/efabless/caravel/blob/9949306c42ded3cad03e1f4566d7cd1f8215b0bb/openlane/chip_io/padframe.cfg
[8]: ./hardening_macros.md
[9]: https://github.com/The-OpenROAD-Project/openlane/tree/master/designs/manual_macro_placement_test
[10]: ./advanced_power_grid_control.md
[11]: https://github.com/efabless/caravel/blob/9949306c42ded3cad03e1f4566d7cd1f8215b0bb/openlane/caravel/interactive.lvs.tcl
