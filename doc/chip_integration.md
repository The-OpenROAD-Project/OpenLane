# Chip Integration

Using openlane, you can produce a GDSII from a chip RTL.

For example, striVe2a:

**Image**

## The current Methodology

The current methodology views the chip using the following hierarchy:
- Chip Core
    - The hard macros
    - The rest of the design
- Chip IO
    - IO Pads
    - Power Pads
    - Corener Pads

The current methodology goes as follows:
1. Hardening the hard macros.
2. Hardening the core with the hard macros inside it.
3. Hardening the full chip with the padframe. 


## Hardening The Macros

The macros are hardened normally through the flow by running `./flow.tcl`. 

Make sure to properly configure your macro to get the expected outcome, if it requires special configurations. [Here][0] you can find a list of all the available OpenLANE configuartions.

If your macro requires special steps or skipping/repeating some steps. Then you should use an [interactive script][2].

If your macro require special power grid setup. Then refer to [this][3] and write your own `pdn.tcl` and point to it by setting `::env(PDN_CFG)`. You could also use `$PDK_ROOT/sky130A/libs.tech/openlane/common_pdn.tcl` as a reference.

## Hardening The Core

The chip core would usually require an [interactive script][2] to harden. You could take this [chip core][4] as an example.

You need to set the following environment variables in your `config.tcl` file for the chip core:
- `::env(VERILOG_FILES)` To point at the used verilog files; those that were not previously hardened.
- `::env(VERILOG_FILES_BLACKBOX)` To point at the blackboxes (the hardened macros).
- `::env(EXTRA_LEFS)` To point at the LEF files of the hardened macros.
- `::env(EXTRA_GDS_FILES)` To point at the GDS files of the hardened macros.

Therefore, the verilog files shouldn't have any includes in any of your verilog files. But use `::env(VERILOG_FILES)` and `::env(VERILOG_FILES_BLACKBOX)` for that purpose.

Add `set ::env(SYNTH_READ_BLACKBOX_LIB) 1`, if you have `::env(VERILOG_FILES_BLACKBOX)` in your configuration file.

[Here][0] you can find a list of all the available OpenLANE configuartions.

If your core requires special power grid setup. Then refer to [this][3] and write your own `pdn.tcl` and point to it by setting `::env(PDN_CFG)`. You could also use `$PDK_ROOT/sky130A/libs.tech/openlane/common_pdn.tcl` as a reference.

## Hardening The Full Chip


The full chip requires an [interactive script][2] to harden. You could take this [full chip][5] as an example.

You need to set the following environment variables in your `config.tcl` file for the chip:
- `::env(VERILOG_FILES)` To point at the used verilog files; those that were not previously hardened. Ideally, this should be only one file.
- `::env(VERILOG_FILES_BLACKBOX)` To point at the blackboxes (the hardened macros). Ideally, this should include all the other verilog files.
- `::env(EXTRA_LEFS)` To point at the LEF files of the hardened core macro.
- `::env(EXTRA_GDS_FILES)` To point at the GDS files of the hardened core macro.

Therefore, the verilog files shouldn't have any includes in any of your verilog files. But use `::env(VERILOG_FILES)` and `::env(VERILOG_FILES_BLACKBOX)` for that purpose.

Add `set ::env(SYNTH_READ_BLACKBOX_LIB) 1`, if you have `::env(VERILOG_FILES_BLACKBOX)` in your configuration file.


The following inputs are provided to produce the final GDSII:

1. Padframe cfg file (provided by the user or generated by padring). [Here][6] is an example.
2. Hardened lef for the core module, generated [here](#hardening-the-core)
3. Top level netlist instantiating pads and core module (Could be provided by the user or generated by [topModuleGen][7])

**Note:** The chip Verilog file should contain a guard `ifdef PFG` under which all the verilog file names should be included, without specifying a directory. This includes the verilog for the pads as well.

Given these inputs the following [interactive script][5] script. Mainly, it does the following steps:
-  set `padframe_root $::env(TMP_DIR)/padframe/<chip design name>/`.
-  Copy all the lef files (of all the macros and power/corner/io pads) to `$padframe/mag`, and all the verilog files to `$padframe/verilog`.
-  Copy the padframe cfg file to `$padframe/mag`.
-  Combine the pads lef, macros lefs and tech lef in one lef file.
-  Use padring to generate the padframe.def and the core.def. 
-  Parse the padframe cfg file to get the diearea and input it to the floorplanner.
-  Run the top level netlist through yosys.
-  Running `chip_floorplan` which first generates a floorplan using `verilog2def` followed by removing PINS section and cleaning NETS section in the generated def file.
-  Replace the components of the floorplan def file with placed components from padframe def file and core def file.
-  Perform manual placement if desired.
-  legalize the placement.
-  Route the design.
-  Perform power routing.
-  Generate a GDSII file of the routed design.
-  Run DRC and LVS checks.



[0]: ./../configuration/README.md
[1]: ./OpenLANE_commands.md
[2]: ./advanced_readme.md
[3]: https://github.com/The-OpenROAD-Project/OpenROAD/blob/openroad/src/pdngen/doc/PDN.md
[4]: Reference_for_interactive_script_core
[5]: Reference_for_interactive_script_chip
[6]: Example_padframe_cfg_file
[7]: ./../scripts/topModuleGen/README.md